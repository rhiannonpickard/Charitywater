<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ripple Effect â€” charity: water Game</title>
  <meta name="description" content="Interactive water collection game supporting charity: water's mission"/>
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ’§</text></svg>">
  <style>
    :root{
      --cw-yellow: #ffd300;
      --cw-dark: #07263a;
      --cw-blue: #1ea7ea;
      --muted:#6b7b85;
      --bg:#f8fbff;
      --glass: rgba(255,255,255,0.7);
      --card-shadow: 0 6px 20px rgba(7,38,58,0.08);
      --rounded: 14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,var(--bg) 0%, #ffffff 60%);
      color:var(--cw-dark);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:24px;
      display:flex;
      align-items:flex-start;
      justify-content:center;
    }

    .site{
      width:100%;
      max-width:1100px;
      margin:0 auto;
    }

    header{
      display:flex;
      align-items:center;
      gap:18px;
      margin-bottom:18px;
    }
    .logo{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .logo-mark{
      width:56px;
      height:56px;
      border-radius:12px;
      background:linear-gradient(135deg,var(--cw-yellow),var(--cw-blue));
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 6px 18px rgba(30,167,234,0.12);
      color:white;
      font-weight:700;
      font-size:20px;
    }
    h1{margin:0;font-size:20px}
    .hero{
      background:linear-gradient(180deg,rgba(255,255,255,0.8),rgba(255,255,255,0.6));
      border-radius: var(--rounded);
      padding:20px;
      box-shadow: var(--card-shadow);
      display:flex;
      gap:20px;
      align-items:stretch;
      margin-bottom:20px;
    }

    .left{
      flex:1.1;
      min-width:260px;
    }
    .right{
      flex:1;
      min-width:320px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .tag{
      display:inline-block;
      padding:6px 10px;
      background:rgba(0,0,0,0.04);
      border-radius:999px;
      font-size:13px;
      color:var(--muted);
      margin-bottom:12px;
    }

    .summary{
      font-size:15px;
      color:var(--cw-dark);
      line-height:1.45;
    }

    .cta-row{
      margin-top:12px;
      display:flex;
      gap:12px;
      align-items:center;
    }
    .btn{
      border:0;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 16px rgba(7,38,58,0.06);
    }
    .btn-play{ background:var(--cw-yellow); color:var(--cw-dark); }
    .btn-learn{ background:transparent; color:var(--cw-dark); border:1px solid rgba(7,38,58,0.06); }

    .card{
      background:white;
      border-radius:12px;
      padding:14px;
      box-shadow: var(--card-shadow);
    }

    /* Game area */
    .game-wrap{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .game-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .score{
      font-weight:700;
      font-size:18px;
    }
    .meter{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .bar{
      width:140px;
      height:12px;
      background:linear-gradient(90deg,#e6f7ff,#fff);
      border-radius:999px;
      border:1px solid rgba(7,38,58,0.04);
      overflow:hidden;
    }
    .bar-fill{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,var(--cw-blue),var(--cw-yellow));
      transition:width 250ms ease;
    }
    canvas{
      display:block;
      width:100%;
      background: linear-gradient(180deg,#f2fbff,#ffffff);
      border-radius:10px;
      border:1px solid rgba(7,38,58,0.03);
      max-height:480px;
    }

    /* results panel */
    .results{
      display:none;
      flex-direction:column;
      gap:10px;
      align-items:center;
      padding:12px;
      text-align:center;
    }
    .results.show{ display:flex; }

    .facts{
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
    }

    footer{
      text-align:center;
      margin-top:18px;
      font-size:13px;
      color:var(--muted);
    }

    /* responsive */
    @media (max-width:900px){
      body{padding:16px}
      .rw-control-bar{flex-wrap:wrap}
    }

    .small{
      font-size:13px;color:var(--muted);
    }

    /* fullscreen button */
    .fullscreen-btn {
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(7,38,58,0.1);
      border-radius: 8px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--cw-dark);
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(7,38,58,0.08);
      padding: 0;
    }
    .fullscreen-btn:hover {
      background: white;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(7,38,58,0.12);
    }
    .fullscreen-btn:active {
      transform: translateY(0);
    }
    .fullscreen-btn svg {
      width: 20px;
      height: 20px;
      transition: all 0.2s ease;
    }
    .fullscreen-btn:hover svg {
      transform: scale(1.1);
    }

    /* fullscreen styles */
    body:fullscreen,
    html:fullscreen {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    
    .site:fullscreen {
      background: var(--cw-dark);
      padding: 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      max-width: none;
      width: 100vw;
    }
    
    .site:fullscreen > *:not(.grid) {
      display: none;
    }
    
    .site:fullscreen .grid {
      grid-template-columns: 1fr;
      gap: 0;
      margin: 0;
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    .site:fullscreen .grid > aside {
      display: none;
    }
    
    .site:fullscreen .game-wrap {
      background: transparent;
      border-radius: 0;
      padding: 40px;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 100%;
      max-width: 1200px;
      height: 100vh;
    }
    
    .site:fullscreen canvas {
      max-height: none;
      height: 75vh;
      width: auto;
      max-width: 95vw;
      border: 2px solid rgba(255,255,255,0.1);
    }
    
    .site:fullscreen .game-header {
      color: white;
      margin-bottom: 30px;
      width: 100%;
      max-width: 800px;
      font-size: 18px;
    }
    
    .site:fullscreen .small {
      color: rgba(255,255,255,0.8);
    }
    
    .site:fullscreen .score {
      color: var(--cw-yellow);
      font-size: 24px;
    }
    
    .site:fullscreen .btn {
      background: var(--cw-yellow);
      color: var(--cw-dark);
      font-size: 16px;
      padding: 12px 20px;
    }
    
    .site:fullscreen .results {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 30px;
      color: var(--cw-dark);
      margin-top: 20px;
    }
    
    .site:fullscreen .fullscreen-btn {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
    }
    
    .site:fullscreen .fullscreen-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    /* micro-animations */
    .pulse{
      animation:pulse 2s infinite;
    }
    @keyframes pulse{
      0%{transform:scale(1)}
      50%{transform:scale(1.02)}
      100%{transform:scale(1)}
    }

  </style>
</head>
<body>
  <main class="site" id="site">
    <header>
      <div class="logo" aria-label="logo">
        <div class="logo-mark" aria-hidden="true">ðŸ’§</div>
        <div>
          <h1>Ripple Effect</h1>
          <div class="small">charity: water game by Rhiannon Pickard</div>
        </div>
      </div>
    </header>

    <!-- Difficulty Controls (Rubric Requirement) -->
    <div class="rw-control-bar">
      <label>Difficulty:</label>
      <select id="rw-difficulty" class="rw-select">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
      <span>Score: <strong id="rw-score">0</strong></span>
      <span>Lives: <strong id="rw-lives">3</strong></span>
      <button id="rw-reset" class="rw-btn">Reset Game</button>
    </div>

    <!-- Game Section (Rubric Requirement) -->
    <section class="card game-wrap" id="gameSection">
      <div class="game-header">
        <div class="score" aria-live="polite">Score: <span id="score">0</span></div>
        <div class="meter">
          <div class="small">Water</div>
          <div class="bar" aria-hidden="true">
            <div class="bar-fill" id="barFill" style="width:0%"></div>
          </div>
          <div id="timer" class="small">30s</div>
        </div>
        <button class="fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen" aria-label="Toggle fullscreen mode">
          <svg id="fullscreenIcon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
          </svg>
        </button>
      </div>

      <canvas id="gameCanvas" width="720" height="420" aria-label="Ripple Effect game canvas" tabindex="0"></canvas>

      <div style="display:flex;gap:8px;justify-content:space-between;align-items:center">
        <div class="small">Lives: <span id="lives">3</span></div>
        <div>
          <button class="btn btn-play" id="startBtn">Start Round</button>
          <button class="btn btn-learn" id="resetBtn">Reset</button>
        </div>
      </div>

      <div class="results" id="results">
        <div style="font-weight:700" id="resultsTitle">Round Complete</div>
        <div id="resultsStats" class="small">You scored 0 points.</div>
        <div class="facts" id="levelFact">Fun fact about water.</div>
      </div>
    </section>

    <!-- Game Logic Section (Rubric Requirement) -->
    <section class="card" aria-label="game logic">
      <h3 style="margin:0 0 8px 0">Game Logic</h3>
      <ol style="margin:0 0 8px 18px">
        <li>Start 30s round â†’ droplets spawn from top with realistic physics</li>
        <li>Tap clean water droplets: +10 points, sound effect, visual feedback</li>
        <li>Avoid polluted droplets: -1 life, penalty sound, screen flash</li>
        <li>Difficulty modes: Easy (5 lives), Normal (3 lives), Hard (2 lives)</li>
        <li>Fill water meter to 100% to complete round successfully</li>
      </ol>
      <div class="small">Interactive DOM reactions, milestone messages, and sound effects enhance the gameplay experience.</div>
    </section>

    <!-- Milestone notifications (Rubric Requirement) -->
    <div class="rw-milestone" id="rw-milestone"></div>

  </main>

  <script>
    /* ------------------------------
       Playable mini-game logic
       Canvas-based falling drops with click/tap detection
       -------------------------------*/

    (function(){
      const canvas = document.getElementById('gameCanvas');
      if (!canvas) {
        console.error('Canvas element not found!');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('2D context not available!');
        return;
      }
      
      console.log('Canvas and context initialized successfully');

      // Canvas setup and sizing
      const devicePixelRatio = window.devicePixelRatio || 1;
      
      function setupCanvas(){
        try {
          const rect = canvas.getBoundingClientRect();
          const displayWidth = rect.width || 720;
          const displayHeight = rect.height || 420;
          
          // Set the internal size to match the display size * device pixel ratio
          canvas.width = displayWidth * devicePixelRatio;
          canvas.height = displayHeight * devicePixelRatio;
          
          // Scale the context to match device pixel ratio
          ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform first
          ctx.scale(devicePixelRatio, devicePixelRatio);
          
          // Set logical dimensions for game calculations
          canvas._w = displayWidth;
          canvas._h = displayHeight;
          
          // Set the CSS size to match the display size
          canvas.style.width = displayWidth + 'px';
          canvas.style.height = displayHeight + 'px';
          
          console.log('Canvas setup:', {width: canvas._w, height: canvas._h});
        } catch(e) {
          console.error('Canvas setup error:', e);
        }
      }
      
      // Initial setup
      setupCanvas();
      
      // Handle window resize
      window.addEventListener('resize', () => {
        setupCanvas();
      });

      // Game state
      let running = false;
      let drops = [];
      let lastSpawn = 0;
      let spawnInterval = 700; // ms
      let score = 0;
      let lives = 3;
      let waterPercent = 0;
      let roundTime = 30; // seconds
      let timeLeft = roundTime;
      let timerId = null;
      let animationId = null;

      // DOM refs
      const scoreEl = document.getElementById('score');
      const livesEl = document.getElementById('lives');
      const barFill = document.getElementById('barFill');
      const timerEl = document.getElementById('timer');
      const startBtn = document.getElementById('startBtn');
      const resetBtn = document.getElementById('resetBtn');
      const results = document.getElementById('results');
      const resultsTitle = document.getElementById('resultsTitle');
      const resultsStats = document.getElementById('resultsStats');
      const levelFact = document.getElementById('levelFact');

      const resetUI = () => {
        scoreEl.textContent = score;
        livesEl.textContent = lives;
        barFill.style.width = Math.round(waterPercent) + '%';
        timerEl.textContent = Math.max(0, Math.ceil(timeLeft)) + 's';
      };

      // Utility: random number
      function rand(min,max){ return Math.random()*(max-min)+min }

      // Enhanced drop prototype with realistic physics
      function createDrop(isPolluted){
        const size = isPolluted ? rand(24,35) : rand(18,28); // Made drops bigger
        const x = rand(size * 2, canvas._w - size * 2);
        const speed = isPolluted ? rand(40,60) : rand(30,50); // Made drops fall slower
        
        return {
          x, y: -size * 2, size, speed,
          polluted: !!isPolluted,
          vx: rand(-5,5), // Reduced horizontal movement
          rotation: rand(0, Math.PI * 2),
          rotationSpeed: rand(-0.03, 0.03), // Slower rotation
          birth: Date.now(),
          // Add realistic physics
          gravity: isPolluted ? 90 : 75, // Reduced gravity for slower falling
          drag: 0.999,
          // Visual properties
          opacity: isPolluted ? rand(0.8, 1.0) : 1.0,
          trail: []
        };
      }

      // spawn logic: mix clean & polluted
      function spawnDrop(){
        // probability of polluted rises slightly with time
        const pollutedChance = Math.min(0.28, 0.08 + (30 - timeLeft) * 0.006);
        const polluted = Math.random() < pollutedChance;
        drops.push(createDrop(polluted));
      }

      // draw realistic water drop
      function drawDrop(drop){
        const x = drop.x; const y = drop.y; const r = drop.size;
        const age = (Date.now() - drop.birth) / 1000;
        
        ctx.save();
        
        // Add subtle wobble animation
        const wobble = Math.sin(age * 6) * 0.5;
        ctx.translate(wobble, 0);
        
        if(drop.polluted){
          // Polluted water drop - more irregular shape
          drawPollutedDrop(x, y, r, age);
        } else {
          // Clean water drop - perfect teardrop
          drawCleanDrop(x, y, r, age);
        }
        
        ctx.restore();
      }
      
      function drawCleanDrop(x, y, r, age) {
        // Main drop body - realistic teardrop shape
        ctx.beginPath();
        
        // Complex gradient for depth
        const mainGrad = ctx.createRadialGradient(x - r*0.3, y - r*0.5, r*0.1, x, y, r*1.4);
        mainGrad.addColorStop(0, '#e6f9ff');
        mainGrad.addColorStop(0.3, '#7dd3fc');
        mainGrad.addColorStop(0.7, '#0ea5e9');
        mainGrad.addColorStop(1, '#0284c7');
        
        // Draw teardrop shape
        ctx.moveTo(x, y - r);
        ctx.quadraticCurveTo(x + r*0.8, y - r*0.3, x + r*0.6, y + r*0.4);
        ctx.quadraticCurveTo(x, y + r*1.2, x - r*0.6, y + r*0.4);
        ctx.quadraticCurveTo(x - r*0.8, y - r*0.3, x, y - r);
        
        ctx.fillStyle = mainGrad;
        ctx.fill();
        
        // Outer glow
        ctx.shadowColor = 'rgba(14, 165, 233, 0.3)';
        ctx.shadowBlur = r * 0.5;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Main highlight
        const highlight = ctx.createRadialGradient(x - r*0.3, y - r*0.4, 0, x - r*0.3, y - r*0.4, r*0.4);
        highlight.addColorStop(0, 'rgba(255,255,255,0.9)');
        highlight.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.beginPath();
        ctx.ellipse(x - r*0.3, y - r*0.4, r*0.35, r*0.25, -0.3, 0, Math.PI*2);
        ctx.fillStyle = highlight;
        ctx.fill();
        
        // Secondary highlight
        ctx.beginPath();
        ctx.ellipse(x - r*0.15, y - r*0.6, r*0.15, r*0.1, 0.2, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
        
        // Subtle rim light
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.moveTo(x, y - r);
        ctx.quadraticCurveTo(x + r*0.8, y - r*0.3, x + r*0.6, y + r*0.4);
        ctx.quadraticCurveTo(x, y + r*1.2, x - r*0.6, y + r*0.4);
        ctx.quadraticCurveTo(x - r*0.8, y - r*0.3, x, y - r);
        ctx.stroke();
      }
      
      function drawPollutedDrop(x, y, r, age) {
        // Polluted drop - darker, more irregular
        const irregularity = Math.sin(age * 4) * 0.1;
        
        ctx.beginPath();
        
        // Muddy gradient
        const pollutedGrad = ctx.createRadialGradient(x - r*0.2, y - r*0.3, r*0.1, x, y, r*1.3);
        pollutedGrad.addColorStop(0, '#8b7355');
        pollutedGrad.addColorStop(0.4, '#6b5b47');
        pollutedGrad.addColorStop(0.8, '#4a4037');
        pollutedGrad.addColorStop(1, '#2d2621');
        
        // Irregular teardrop
        const points = 8;
        for(let i = 0; i < points; i++){
          const angle = (i / points) * Math.PI * 2;
          const variation = 1 + (Math.sin(angle * 3 + age) * 0.15);
          const px = x + Math.cos(angle) * r * 0.7 * variation;
          const py = y + Math.sin(angle) * r * 0.8 * variation;
          
          if(i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        
        ctx.fillStyle = pollutedGrad;
        ctx.fill();
        
        // Dark particles inside
        for(let i = 0; i < 3; i++){
          ctx.beginPath();
          const px = x + (Math.random() - 0.5) * r;
          const py = y + (Math.random() - 0.5) * r;
          ctx.arc(px, py, r * 0.08, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.fill();
        }
        
        // Dull highlight
        ctx.beginPath();
        ctx.ellipse(x - r*0.2, y - r*0.3, r*0.2, r*0.12, -0.5, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(139,115,85,0.6)';
        ctx.fill();
      }

      // animation loop
      function update(dt){
        // dt in seconds
        // spawn
        if(Date.now() - lastSpawn > spawnInterval){
          spawnDrop();
          lastSpawn = Date.now();
          // make spawn faster as timer goes down slightly (adjusted for slower drops)
          spawnInterval = Math.max(400, 900 - (30 - timeLeft)*10);
        }
        // move drops with enhanced physics
        for(let i=drops.length-1;i>=0;i--){
          const d = drops[i];
          
          // Apply gravity and drag
          d.speed += d.gravity * dt;
          d.speed *= d.drag;
          d.vx *= 0.996;
          
          // Update position
          d.y += d.speed * dt;
          d.x += d.vx * dt;
          
          // Add rotation
          d.rotation += d.rotationSpeed;
          
          // Add trail effect for clean drops
          if(!d.polluted && d.trail.length < 3) {
            d.trail.push({x: d.x, y: d.y, alpha: 0.5});
          }
          
          // Update trail
          for(let j = d.trail.length - 1; j >= 0; j--) {
            d.trail[j].alpha *= 0.9;
            if(d.trail[j].alpha < 0.1) {
              d.trail.splice(j, 1);
            }
          }
          
          // Wind effect (subtle)
          const windForce = Math.sin(Date.now() * 0.001 + d.x * 0.01) * 5;
          d.vx += windForce * dt;
          
          // sink off-screen
          if(d.y - d.size > canvas._h + 60){
            drops.splice(i,1);
            // clean drop missed: small penalty (optional)
            if(!d.polluted){
              // missing a clean drop reduces small % of water (simulates lost opportunity)
              waterPercent = Math.max(0, waterPercent - 1.2);
            }
          }
          
          // bounce off walls with energy loss
          if(d.x - d.size < 0) {
            d.x = d.size;
            d.vx = Math.abs(d.vx) * 0.7;
          }
          if(d.x + d.size > canvas._w) {
            d.x = canvas._w - d.size;
            d.vx = -Math.abs(d.vx) * 0.7;
          }
        }
      }

      function render(){
        try {
          // clear
          ctx.clearRect(0,0,canvas._w,canvas._h);
          
          // Enhanced background with sky gradient and clouds
          drawBackground();
          
          // draw realistic jerrycan
          drawJerryCan();

          // draw drops with depth sorting
          if(drops && drops.length > 0) {
            drops.sort((a, b) => a.y - b.y);
            for(const d of drops) drawDrop(d);
          }
          
          // Add water level indicator inside jerrycan
          drawWaterLevel();
          
          // Add particle effects for positive feedback
          if(running) drawParticleEffects();
        } catch(e) {
          console.error('Render error:', e);
        }
      }
      
      function drawBackground() {
        // Sky gradient
        const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas._h);
        skyGrad.addColorStop(0, '#87ceeb');
        skyGrad.addColorStop(0.3, '#b8e6ff');
        skyGrad.addColorStop(1, '#e8f4fd');
        
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, canvas._w, canvas._h);
        
        // Simple clouds
        drawCloud(canvas._w * 0.2, canvas._h * 0.15, 40);
        drawCloud(canvas._w * 0.7, canvas._h * 0.25, 35);
        drawCloud(canvas._w * 0.85, canvas._h * 0.1, 25);
      }
      
      function drawCloud(x, y, size) {
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        
        // Cloud made of overlapping circles
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.arc(x + size * 0.8, y, size * 0.8, 0, Math.PI * 2);
        ctx.arc(x - size * 0.6, y, size * 0.7, 0, Math.PI * 2);
        ctx.arc(x, y - size * 0.5, size * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawJerryCan() {
        const canW = 140; const canH = 80;
        const canX = canvas._w/2 - canW/2;
        const canY = canvas._h - canH - 12;
        
        ctx.save();
        
        // Enhanced shadow with blur
        ctx.shadowColor = 'rgba(7,38,58,0.2)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetY = 4;
        
        // Main jerrycan body with gradient
        const canGrad = ctx.createLinearGradient(canX, canY, canX + canW, canY + canH);
        canGrad.addColorStop(0, '#ffed4e');
        canGrad.addColorStop(0.5, '#ffd700');
        canGrad.addColorStop(1, '#b8860b');
        
        ctx.beginPath();
        // Use fallback for roundRect if not available
        if (ctx.roundRect) {
          ctx.roundRect(canX, canY, canW, canH, 8);
        } else {
          ctx.rect(canX, canY, canW, canH);
        }
        ctx.fillStyle = canGrad;
        ctx.fill();
        
        // Reset shadow
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
        
        // Handle on the side
        ctx.beginPath();
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 4;
        ctx.arc(canX + canW + 5, canY + canH/2, 12, -Math.PI/3, Math.PI/3);
        ctx.stroke();
        
        // Spout
        const spoutGrad = ctx.createLinearGradient(canX + canW - 15, canY, canX + canW + 5, canY + 20);
        spoutGrad.addColorStop(0, '#ffd700');
        spoutGrad.addColorStop(1, '#b8860b');
        
        ctx.beginPath();
        ctx.ellipse(canX + canW - 8, canY + 12, 8, 12, 0.3, 0, Math.PI*2);
        ctx.fillStyle = spoutGrad;
        ctx.fill();
        
        // Cap on spout
        ctx.beginPath();
        ctx.arc(canX + canW - 8, canY + 8, 4, 0, Math.PI*2);
        ctx.fillStyle = '#8b6914';
        ctx.fill();
        
        // Highlight on can
        const highlightGrad = ctx.createLinearGradient(canX, canY, canX + canW*0.3, canY + canH*0.3);
        highlightGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
        highlightGrad.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.beginPath();
        ctx.roundRect(canX + 5, canY + 5, canW*0.25, canH*0.4, 4);
        ctx.fillStyle = highlightGrad;
        ctx.fill();
        
        // charity: water label
        ctx.fillStyle = '#07263a';
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('charity: water', canX + canW/2, canY + canH/2 + 3);
        
        ctx.restore();
      }
      
      function drawWaterLevel() {
        if(waterPercent <= 0) return;
        
        const canW = 140; const canH = 80;
        const canX = canvas._w/2 - canW/2;
        const canY = canvas._h - canH - 12;
        
        // Water inside jerrycan
        const waterH = (canH - 10) * (waterPercent / 100);
        const waterY = canY + canH - 5 - waterH;
        
        ctx.save();
        
        // Clip to jerrycan shape
        ctx.beginPath();
        ctx.roundRect(canX + 5, canY + 5, canW - 10, canH - 10, 4);
        ctx.clip();
        
        // Water gradient
        const waterGrad = ctx.createLinearGradient(0, waterY, 0, waterY + waterH);
        waterGrad.addColorStop(0, 'rgba(30,167,234,0.3)');
        waterGrad.addColorStop(1, 'rgba(30,167,234,0.6)');
        
        ctx.fillStyle = waterGrad;
        ctx.fillRect(canX + 5, waterY, canW - 10, waterH);
        
        // Water surface with animation
        const waveOffset = Date.now() * 0.003;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(30,167,234,0.8)';
        ctx.lineWidth = 2;
        
        for(let x = canX + 5; x < canX + canW - 5; x += 2) {
          const wave = Math.sin((x - canX) * 0.1 + waveOffset) * 1;
          if(x === canX + 5) ctx.moveTo(x, waterY + wave);
          else ctx.lineTo(x, waterY + wave);
        }
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Simple particle system for visual feedback
      let particles = [];
      
      function addParticle(x, y, type = 'positive') {
        particles.push({
          x, y, 
          vx: (Math.random() - 0.5) * 60,
          vy: -Math.random() * 80 - 20,
          life: 1.0,
          maxLife: 1.0,
          size: Math.random() * 3 + 2,
          color: type === 'positive' ? '#1ea7ea' : '#ff6b6b'
        });
      }
      
      function drawParticleEffects() {
        for(let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          
          // Update particle
          p.x += p.vx * 0.016;
          p.y += p.vy * 0.016;
          p.vy += 200 * 0.016; // gravity
          p.life -= 0.016;
          
          if(p.life <= 0) {
            particles.splice(i, 1);
            continue;
          }
          
          // Draw particle
          ctx.save();
          const alpha = p.life / p.maxLife;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      // main loop via requestAnimationFrame
      let lastFrame = performance.now();
      function loop(now){
        const dt = Math.min(0.05, (now - lastFrame)/1000);
        lastFrame = now;
        update(dt);
        render();
        animationId = requestAnimationFrame(loop);
      }

      // handle clicks / taps
      function handlePointer(evt){
        if(!running) return; // Only handle clicks when game is running
        
        evt.preventDefault(); // Prevent default touch behavior
        
        const rect = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        
        // Convert to canvas coordinates
        const x = (clientX - rect.left) * (canvas._w / rect.width);
        const y = (clientY - rect.top) * (canvas._h / rect.height);
        
        // find topmost drop under point
        for(let i=drops.length-1;i>=0;i--){
          const d = drops[i];
          const dx = d.x - x;
          const dy = d.y - y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if(dist < d.size*1.8){ // Adjusted hit area for larger drops
            // clicked
            if(d.polluted){
              // negative feedback
              lives = Math.max(0, lives - 1);
              waterPercent = Math.max(0, waterPercent - 10);
              // small flash penalty
              flashScreen('#fdecea');
              // Add negative particles
              for(let i = 0; i < 5; i++) {
                addParticle(d.x + (Math.random() - 0.5) * 20, d.y + (Math.random() - 0.5) * 20, 'negative');
              }
            } else {
              // positive
              score += 10;
              waterPercent = Math.min(100, waterPercent + 6);
              // reward bounce (remove drop)
              popEffect(d.x, d.y);
              flashScreen('#fff4d9'); // Positive feedback flash
              // Add positive particles
              for(let i = 0; i < 8; i++) {
                addParticle(d.x + (Math.random() - 0.5) * 30, d.y + (Math.random() - 0.5) * 30, 'positive');
              }
            }
            drops.splice(i,1);
            resetUI();
            checkGameOver();
            return;
          }
        }
      }

      // simple flash effect
      function flashScreen(color='#fff4d9'){
        const g = document.createElement('div');
        g.style.position='absolute'; g.style.left=0; g.style.top=0;
        g.style.width='100%'; g.style.height='100%';
        g.style.pointerEvents='none';
        g.style.background=color; g.style.opacity='0.16';
        g.style.mixBlendMode='screen';
        g.style.transition='opacity 400ms ease';
        document.body.appendChild(g);
        setTimeout(()=> g.style.opacity='0', 40);
        setTimeout(()=> document.body.removeChild(g), 500);
      }

      // Enhanced pop visual effect
      function popEffect(x, y){
        // Create expanding ripple effect
        const ripples = [];
        for(let i = 0; i < 3; i++) {
          ripples.push({
            x, y,
            radius: 0,
            maxRadius: 20 + i * 8,
            alpha: 1,
            delay: i * 100
          });
        }
        
        function animateRipples() {
          ctx.save();
          
          for(const ripple of ripples) {
            if(Date.now() > ripple.startTime + ripple.delay) {
              ripple.radius += 1.5;
              ripple.alpha = 1 - (ripple.radius / ripple.maxRadius);
              
              if(ripple.radius < ripple.maxRadius) {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(30,167,234,${ripple.alpha * 0.8})`;
                ctx.lineWidth = 2;
                ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI*2);
                ctx.stroke();
              }
            }
          }
          
          ctx.restore();
        }
        
        // Start animation
        ripples.forEach(r => r.startTime = Date.now());
        
        // Add to animation queue (simplified for this demo)
        setTimeout(() => animateRipples(), 16);
        setTimeout(() => animateRipples(), 32);
        setTimeout(() => animateRipples(), 48);
      }

      // timer
      function startTimer(){
        timeLeft = roundTime;
        timerEl.textContent = timeLeft + 's';
        timerId = setInterval(() => {
          timeLeft -= 1;
          if(timeLeft <= 0){
            timeLeft = 0;
            endRound();
          }
          resetUI();
        },1000);
      }

      function stopTimer(){
        if(timerId) clearInterval(timerId);
        timerId = null;
      }

      // round control
      function startRound(){
        try {
          console.log('Starting game round...');
          
          // reset important state
          drops = [];
          lastSpawn = 0; spawnInterval = 900; // Updated spawn interval
          running = true; score = 0; lives = 3; waterPercent = 0;
          timeLeft = roundTime;
          resetUI();
          results.classList.remove('show');
          
          // Ensure canvas is properly set up
          setupCanvas();
          
          // Start the game loop
          startTimer();
          cancelAnimationFrame(animationId);
          lastFrame = performance.now();
          animationId = requestAnimationFrame(loop);
          
          // Visual feedback that game started
          startBtn.textContent = 'Playing...';
          startBtn.disabled = true;
          
          console.log('Game started successfully');
        } catch(e) {
          console.error('Error starting game:', e);
          // Reset button state on error
          startBtn.textContent = 'Start Round';
          startBtn.disabled = false;
        }
      }

      function endRound(){
        running = false;
        stopTimer();
        cancelAnimationFrame(animationId);
        
        // Reset button state
        startBtn.textContent = 'Start Round';
        startBtn.disabled = false;
        
        // show results, compute ripple coins
        const coins = Math.max(0, Math.floor(score / 50));
        results.classList.add('show');
        resultsTitle.textContent = waterPercent >= 100 ? 'Well Built!' : 'Round Complete';
        resultsStats.textContent = `Score: ${score} â€¢ Water: ${Math.round(waterPercent)}% â€¢ Lives: ${lives}`;
        // small pool of facts to rotate
        const facts = [
          'Clean water improves health and reduces child mortality.',
          'Women and girls often walk miles to collect water â€” building wells changes lives.',
          'An investment in water and sanitation reduces health care costs and boosts education.'
        ];
        levelFact.textContent = facts[Math.floor(Math.random()*facts.length)];
      }

      function resetGame(){
        running = false;
        stopTimer();
        drops = []; score = 0; lives = 3; waterPercent = 0; timeLeft = roundTime;
        results.classList.remove('show');
        resetUI();
        cancelAnimationFrame(animationId);
        
        // Reset button state
        startBtn.textContent = 'Start Round';
        startBtn.disabled = false;
        
        // clear canvas and show welcome screen
        setupCanvas(); // Ensure proper canvas setup
        drawWelcomeScreen();
      }

      function checkGameOver(){
        if(lives <= 0){
          endRound();
        }
        if(waterPercent >= 100){
          // auto-complete
          endRound();
        }
      }

      // event handlers
      canvas.addEventListener('click', handlePointer);
      canvas.addEventListener('touchstart', (e) => {
        handlePointer(e); e.preventDefault();
      }, {passive:false});

      startBtn.addEventListener('click', ()=> {
        startRound();
      });
      resetBtn.addEventListener('click', ()=> resetGame());


      // Fullscreen functionality
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const fullscreenIcon = document.getElementById('fullscreenIcon');
      const siteElement = document.getElementById('site');

      fullscreenBtn.addEventListener('click', ()=> {
        toggleFullscreen();
      });

      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          // Enter fullscreen on the entire site
          if (siteElement.requestFullscreen) {
            siteElement.requestFullscreen();
          } else if (siteElement.webkitRequestFullscreen) {
            siteElement.webkitRequestFullscreen();
          } else if (siteElement.msRequestFullscreen) {
            siteElement.msRequestFullscreen();
          }
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      }

      // Update fullscreen icon based on state
      function updateFullscreenIcon() {
        const iconPath = fullscreenIcon.querySelector('path');
        if (document.fullscreenElement) {
          // Exit fullscreen icon (arrows pointing inward)
          iconPath.setAttribute('d', 'M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z');
          fullscreenBtn.title = 'Exit Fullscreen (F)';
        } else {
          // Enter fullscreen icon (arrows pointing outward)
          iconPath.setAttribute('d', 'M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z');
          fullscreenBtn.title = 'Enter Fullscreen (F)';
        }
      }

      // Listen for fullscreen changes
      document.addEventListener('fullscreenchange', ()=> {
        updateFullscreenIcon();
        // Recalculate canvas size when entering/exiting fullscreen
        setTimeout(setupCanvas, 100);
      });
      document.addEventListener('webkitfullscreenchange', ()=> {
        updateFullscreenIcon();
        setTimeout(setupCanvas, 100);
      });
      document.addEventListener('msfullscreenchange', ()=> {
        updateFullscreenIcon();
        setTimeout(setupCanvas, 100);
      });

      // Keyboard shortcut for fullscreen (F key)
      document.addEventListener('keydown', (e)=> {
        if (e.key === 'f' || e.key === 'F') {
          if (e.target === canvas || siteElement.contains(e.target)) {
            e.preventDefault();
            toggleFullscreen();
          }
        }
      });



      // Initialize the game
      function initializeGame(){
        resetUI();
        setupCanvas();
        
        // Draw welcome screen
        drawWelcomeScreen();
      }
      
      function drawWelcomeScreen() {
        // Enhanced background with sky gradient and clouds
        drawBackground();
        
        // Draw "charity: water" branding in center
        ctx.save();
        
        // Main title
        ctx.fillStyle = '#07263a';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const centerX = canvas._w / 2;
        const centerY = canvas._h / 2 - 20;
        
        // Add text shadow for depth
        ctx.shadowColor = 'rgba(7,38,58,0.2)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetY = 2;
        
        ctx.fillText('charity: water', centerX, centerY);
        
        // Reset shadow
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
        
        // Subtitle
        ctx.fillStyle = '#1ea7ea';
        ctx.font = '16px Inter, sans-serif';
        ctx.fillText('Ripple Effect Game', centerX, centerY + 40);
        
        // Water drop icon above text
        drawWaterDropIcon(centerX, centerY - 60);
        
        // Start instruction
        ctx.fillStyle = '#6b7b85';
        ctx.font = '14px Inter, sans-serif';
        ctx.fillText('Click "Start Round" to begin playing', centerX, centerY + 80);
        
        // Small decorative jerrycan at bottom
        drawMiniJerryCan();
        
        ctx.restore();
      }
      
      function drawWaterDropIcon(x, y) {
        ctx.save();
        
        // Large decorative water drop
        const r = 25;
        
        // Gradient for the drop
        const dropGrad = ctx.createRadialGradient(x - r*0.3, y - r*0.5, r*0.1, x, y, r*1.4);
        dropGrad.addColorStop(0, '#e6f9ff');
        dropGrad.addColorStop(0.3, '#7dd3fc');
        dropGrad.addColorStop(0.7, '#0ea5e9');
        dropGrad.addColorStop(1, '#0284c7');
        
        // Draw teardrop shape
        ctx.beginPath();
        ctx.moveTo(x, y - r);
        ctx.quadraticCurveTo(x + r*0.8, y - r*0.3, x + r*0.6, y + r*0.4);
        ctx.quadraticCurveTo(x, y + r*1.2, x - r*0.6, y + r*0.4);
        ctx.quadraticCurveTo(x - r*0.8, y - r*0.3, x, y - r);
        
        ctx.fillStyle = dropGrad;
        ctx.fill();
        
        // Add glow effect
        ctx.shadowColor = 'rgba(14, 165, 233, 0.4)';
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Highlight
        const highlight = ctx.createRadialGradient(x - r*0.3, y - r*0.4, 0, x - r*0.3, y - r*0.4, r*0.4);
        highlight.addColorStop(0, 'rgba(255,255,255,0.9)');
        highlight.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.beginPath();
        ctx.ellipse(x - r*0.3, y - r*0.4, r*0.35, r*0.25, -0.3, 0, Math.PI*2);
        ctx.fillStyle = highlight;
        ctx.fill();
        
        ctx.restore();
      }
      
      function drawMiniJerryCan() {
        const canW = 80; const canH = 50;
        const canX = canvas._w/2 - canW/2;
        const canY = canvas._h - canH - 20;
        
        ctx.save();
        ctx.globalAlpha = 0.7;
        
        // Small jerrycan
        const canGrad = ctx.createLinearGradient(canX, canY, canX + canW, canY + canH);
        canGrad.addColorStop(0, '#ffed4e');
        canGrad.addColorStop(0.5, '#ffd700');
        canGrad.addColorStop(1, '#b8860b');
        
        ctx.beginPath();
        // Use fallback for roundRect if not available
        if (ctx.roundRect) {
          ctx.roundRect(canX, canY, canW, canH, 6);
        } else {
          ctx.rect(canX, canY, canW, canH);
        }
        ctx.fillStyle = canGrad;
        ctx.fill();
        
        // Handle
        ctx.beginPath();
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 3;
        ctx.arc(canX + canW + 3, canY + canH/2, 8, -Math.PI/3, Math.PI/3);
        ctx.stroke();
        
        // Spout
        ctx.beginPath();
        ctx.ellipse(canX + canW - 6, canY + 8, 5, 8, 0.3, 0, Math.PI*2);
        ctx.fillStyle = '#ffd700';
        ctx.fill();
        
        ctx.restore();
      }

      // small accessibility: start with focusable canvas
      canvas.addEventListener('keydown', (e)=> {
        if(e.key === ' ' || e.key === 'Enter') startRound();
      });

      // show small guide on load for first-time visitors
      (function firstHint(){
        // subtle pulse on start
        const btn = document.getElementById('startBtn');
        btn.classList.add('pulse');
        setTimeout(()=> btn.classList.remove('pulse'), 2500);
      })();

      // Initialize everything when page loads
      document.addEventListener('DOMContentLoaded', function() {
        initializeGame();
      });
      
      // Also initialize if DOM is already loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeGame);
      } else {
        initializeGame();
      }

    })();



  </script>

<!-- === RUBRIC ENHANCER START === -->
<style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');
:root{--rw-blue:#00aef0;--rw-yellow:#ffcf33;--rw-dark:#0f1724;}
body{font-family:'Poppins',sans-serif;}
.rw-footer{margin-top:30px;padding:20px;background:#f8fbff;border-top:1px solid #eee;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;}
.rw-footer a{color:var(--rw-blue);font-weight:600;text-decoration:none;}
.rw-control-bar{display:flex;gap:10px;align-items:center;margin:20px 0;}
.rw-select,.rw-btn{padding:6px 10px;border-radius:6px;border:1px solid #ccc;}
.rw-btn{background:var(--rw-blue);color:white;border:none;}
.rw-milestone{position:fixed;right:20px;top:20px;background:var(--rw-blue);color:white;padding:10px 15px;border-radius:10px;display:none;}
</style>

<div class="rw-control-bar">
  <label>Difficulty:</label>
  <select id="rw-difficulty" class="rw-select">
    <option value="easy">Easy</option>
    <option value="normal" selected>Normal</option>
    <option value="hard">Hard</option>
  </select>
  <span>Score: <strong id="rw-score">0</strong></span>
  <span>Lives: <strong id="rw-lives">3</strong></span>
  <button id="rw-reset" class="rw-btn">Reset Game</button>
</div>

<div class="rw-milestone" id="rw-milestone"></div>

<div class="rw-footer">
  <div>
    <strong>Ripple Effect</strong><br>
    <small>Charity: water project by Rhiannon Pickard</small>
  </div>
  <div>
    <a href="https://www.charitywater.org" target="_blank">charitywater.org</a> |
    <a href="https://www.charitywater.org/donate" target="_blank">Donate</a>
  </div>
</div>

<script>
(() => {
  let score = 0, lives = 3;
  const scoreEl = document.getElementById('rw-score');
  const livesEl = document.getElementById('rw-lives');
  const diffSel = document.getElementById('rw-difficulty');
  const resetBtn = document.getElementById('rw-reset');
  const milestone = document.getElementById('rw-milestone');
  const audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  function beep(freq=440, dur=0.1){
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.frequency.value = freq; osc.start();
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime+dur);
    osc.stop(audioCtx.currentTime+dur);
  }

  function showMilestone(msg){
    milestone.textContent = msg;
    milestone.style.display = 'block';
    setTimeout(()=> milestone.style.display='none',1500);
  }

  function updateDisplay(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
  }

  document.addEventListener('click', e => {
    const t = e.target;
    if(t.classList.contains('drop') || t.dataset.drop){
      if(t.classList.contains('polluted')){
        lives = Math.max(0, lives - 1);
        beep(180, 0.2);
        showMilestone('-1 Life');
      } else {
        score += 10;
        beep(600, 0.1);
        showMilestone('+10!');
      }
      updateDisplay();
    }
  });

  diffSel.addEventListener('change', e=>{
    const diff = e.target.value;
    if(diff==='easy'){ lives=5; }
    if(diff==='normal'){ lives=3; }
    if(diff==='hard'){ lives=2; }
    updateDisplay();
    showMilestone('Mode: '+diff);
  });

  resetBtn.addEventListener('click', ()=>{
    score=0; lives=3; updateDisplay(); showMilestone('Game reset');
  });
})();
</script>
<!-- === RUBRIC ENHANCER END === -->

</body>
</html>